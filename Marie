Marie - простий компютер. Складається з памяті та центрального процесора. У центрального процесора є 7 регістрів, деякі з яких звязані з памяттю і можуть брати звідти дані. 7:
1. AC: акумулятор, який зберігає значення даних. Це регістр загального значення і містить дані, які проц повинен обробити.
2. MAR: регістр адреси памяті, який містить адресу памяті, на яку посилаються дані.
3. MBR: буферний регістр памяті, який містить щойно прочитані з памяті дані або дані, готові до запису в память.
4. PC: програмний лічильник, який містить адресу наступної інструкції, що має виконуватися.
5. IR: регістр команд, у якому зберігається наступна інструкція, що має бути виконана.
6. InREG: вхідний регістр, який містить дані з прийстрою введення.
7. OutREG: вихідний регістр, який містить дані для вихідного прийстрою.
Не можна зберігати у регістрі значення, не притаманне для нього.
MARIE не може передавати дані в регустр чи виводити їх з нього без шини.
Кожен прийстрій, підключений до шини, має ідентифікаційний номер, і перед тим, як пристрій почне використовувати шину, йому треба ідентифікаційний номер. Регістри та память підключені шинами між собою. Є загальна шина. Ці додаткові шляхи потрібні, щоб організувати парамельну роботу з даними.
ISA - архітертура набору інструкцій - визначає інструкції, які можу виконувати компютер, і формат кожної інструкції. Це по суті інтерфейс між програмним та апаратним забезпеченням.
Кожна іструкція в MARIE складається з 16 бітів. Найзначущі біти - перші 4 - 12-15, що складають код операції, яку треба виконати. Найменш значущі біти 0-11, що утворюють адресу памяті, задають її максимум.
ISA складається з інструкцій для обробки даних, переміщення даних і керування послідовністю виконання програм.
Інструкція Load дозвляє переміщувати дані з памяті в центальний процесор (через MBR і AC). Всі дані (крім інструкцій) повинні спочатку бути поміщені в MBR, а потім - в AC або ALU. AC по замовчуванню.
Інструкція Store дозволяє переміщати дані з процесора назад в память.
Інстуркції Add і Subt додають і віднімають значення до даних, розташованих за адресою X, або від значень з AC. Дані з X копіюються в MBR, де вони зберігаються, доки не буде виконана арифметична операція.
Інструкції Input та Output дозволяють MARIE спілкуватися з навколишнім світом.
Інструкція Halt припиняє виконання поточної програми.
Інструкція Skipcond дозволяє створювати умовне розгалуження (як умовний оператор if або цикл while). При запуску інтрукції перевіряється значення в AC. Два біти адреси (напр 10 і 11 біти, близькі до області opcode) вказують умову, за якою треба перевіряти. Якщо два біти 00 (11 біт - 0 і 10 - 0), це означає, що треба "пропустити, якщо AC негативний". Якщо два біти 01 (11 = 0, 10 = 1), означає "пропустити, якщо AC дорівнює 0". Якщо 2 біти 10, означає "пропустити, якщо AC більше 0". Під словом "пропустити" маєтсья на увазі перейти до наступної інструкції. Це досягається збільшенням PC на 1, по суті ігноруючи наступну інструкцію.
Інструкція Jump - розгалуження без умови. Вона приводить до заміни вміст PC на значення X, яке є адресою наступної інструкції на отримання.
Інструкція складається з 16 біт. Перші 4 зліва - 15-12 - вказують на код операції, яку треба виконати. Наприклад, 0001 - двійкова 1 - представляє інтрукцію Load. Решта 12 - 11-0 - вказують на адресу значення, яке ви завантажуємо, наприклад 000000000011 - двійкова 3 - значення під адресою 3 в основній памяті. Значення під адресою 3 скопійовано в AC. Загалом інструкція має вигляд: 0001000000000011.
0011 - переведена 3 - інструкція Add. Адреса - 000000001101 - 13 в десятковій, 00D в шістнадцятковій - адреса. Значення звідти додаємо до AC. Так, значення в AC - сума.
1001 100000000000 - інструкція Skipcond. Біт 11 і 10 - 10 - значення 2, що означає "попустити, якщо AC більше або дорівнює 0". Якщо менше 0, то ми перейдемо до наступної інструкції. Якщо більше чи дорівнює 0, то інструкція збільшує PC на 1, таким чином пропускаючи наступну інструкцію і викликає наступну після неї.
Мнемоніки (Load, Add) - інструкції мови Асемблер. Бінарні коди (0001, 1001), що відповідають мнемонікам - машинні інстуркцію. Тобто між мовою Асебмлер і машинними інструкціями є відповідність один до одного. Якщо ми друкуємо на мові Асемблер, нам потрібен асемблер, що перевести інструкції в бінарні еквіваленти.
Шини забезпечують протікання інформації через систему.
Набір више названих інструкцій становить набір інструкцій машинного рівня, які використовуються компонентами компютера (реєстрами, арифметично логічнимим блоками, памяттю, декодерами, блоками керування) для виконання програми. Звісно, ці інструкції включають в себе ще й міні інструкції, які приводять до бажаного функціоналу. Напр Load перед для передачі в AC спочатку викликає MAR -> MBR -> AC. Ці мініінструкції називаються мікроопераціями і вказують на елементарні операції, які можна виконувати над даними, що зберігаються в регістрах.
Регістрова нотація передачі (RTN) або мова передачі регістра (RNL) - символьны позначення, яке використовуються для опису поведінки мікрооперацій. M[X] - фактичні дані, що зберігаються в місті X в памяті, <- - позначення передачі інформації.
Реально передача з одного регістру в інший означає передачу на шину з вихідного регістра і потім перенесення з шини в реєстр призначення.
Позначення передачі реєстру для кожної інструкції:
1. Load X - завантажує вміст памяті X в AC. Але спочатку потрібно помістити адресу в MAR. Потім дані в місці M[MAR] (чи за адресою X) переміщуються в MBR. Нарешті, дані розміщуються в AC:
MAR <- X
MBR <- M[MAR], AC <- MBR
Оскільки IR повинен використовувати шину, щоб скопіювати значення в MAR, до того як дані в місці X можна помістити в MBR, для цієї операції потрібні дві цикла шини. Таким чином, ці дві операції розміщені в окремих рядках, щоб вказати, що вони не можуть відбуватися протягом одного циклу. Але, оскільки між AC і MBR особливий звязок, дані можуть передаватися з MBR в AC одразу після того, як вони помістяться в MBR, не чекаючи шини.
2. Store X - зберігає вміст AC в X:
MAR <- X, MBR <- AC
M[MAR] <- MBR
3. Add X - значення за адресою X додаються до AC, поміщає результат в AC:
MAP <- X
MBR <- M[MAR]
AC <- AC + MBR
4. Subt X - подібна до додавання, тільки віднімає:
MAP <- X
MBR <- M[MAR]
AC <- AC - MBR
5. Input - любий вхід з пристрою введення спочатку направляється в InREG, потім передається в AC:
AC <- InREG
6. Output - вміст AC поміщається в OutREG, що в кінцевому підсумку надсилається на вихідний пристрій:
OutREG <- AC
7. Halt - над регістрами не виконується операція, машина просто припиняє виконання
8. Skipcond - розглядає біти 11 і 10 що визначити, яке порівняння виконати на AC. Перевіряється, і якщо умова істинна, то наступна інструкція пропускається. Це виконується збільшенням регістра PC на один:
if IR[11-10] = 00 then 
	if AC < 0 then PC <- PC+1
else if IR[11-10] = 01 then 
	if AC = 0 then PC <- PC+1
else if IR[11-10] = 10 then
	if AC > 0 then PC <- PC+1
Якщо біти в 11 і 10 дорівнюють 11, виникає помилкова умова.
9. Jump X - викликає розгалуження на дану адресу X. Тому цю адресу треба завантажити в PC:
PC <- X або
PC <- IR[11-0], але попереднє позначення легше.
Позначення передачі реєстру є символічним засобом вираження того, що відбувається в системі під час виконання програми.
Обробка інстуркцій. Усі компютери дотримуються базового машинного циклу: цикл отримання-декодування-виконання. Цикл представляє кроки, яким слідує компютер для запуску програми. ЦП отримує інструкцію (передає її з основної памяті в регістр інструкції), декодує її (визначає код операції та отримує дані, необхідні для виконання інструкції) та виконує. Велика частина цього циклу витрачаєть на копіювання даних з одного місця в інше. Коли програма завантажується, адреса першої інструкції повинна бути розміщена в PC. Кроки цього циклу на різних тактах:
1. Копіювання вмість PC в MAR: MAR <- PC
2. Перехід в основну память та завантаження інструкції, знайдену за адресою в MAR, розміщення її в IR, збільшення PC на 1:
IR <- M[MAR]
PC <- PC+1
3. Скопіювати крайні праві 12 біт IR в MAR, декодувати чотири крайні ліві 4 біти для визначення коду операції:
MAR <- IR[11-0]
IR[15-12]
4. При необхідності скористатися адресою в MAR для переходу в память для отримання даних, розміщуючи дані в MBR (можливо в AC), потім виконати інструкцію MBR <- M[MAR] і виконати основну інструкцію.
При написанні програми можна писати мітки: X, 100 -> Load X. Мітка переводиться в адресу в памяті.
При створенні міток Асембле вдічі проходить по коду. На першому проході він створює набір відповідностей - таблицю символів. За один прохід він скласти прогу не може. 
У Асемблера є власні директиви - інструкції спеціально для асемблера, що не перекладаються на машинну мову. Наприклад: DEC, HEX. Асемблер перетворює десяткове число перед тим як зберегли значення. Ще директива - коментар /.
Компілятори (напр C++) спочатку переводять код на Асемблер, а потім - на машинний код. Корисно після збірки правити код Асемблера для кращої оптимізації. Компілятор також оптимізує, але можна ще краще.
Всього для інтсрукції доступно 4 біта, тобто можливо 16 інструкцій. 9 вже знаємо. Додаємо ще 4:
0 - JnS X - зберігає PC за адресою X та переходить до X+1 (jump-and-store)
A - Clear - кладе всі нулі в AC
B - AddI X - непряме додавання
C - JumpI X - непряме перескочення
JnS X ставить точку повернення на X та переходить на інші інструкції. Потім можна повернутися. Це ніби підпрограма (функція).
Clear заощадить машинний цикл, під час якого з памяті завантажувався 0.
AddI X / JumpI X використовують інший режим адресації. Так, замість того, щоб використовувати (додавати/перестрибувати) адресу X, ми беремо звідти значення і розглядаємо його як адресу, з якою треба маніпулювати. Це - непряма адресація.
JnS:
MBR <- PC
MAR <- X
M[MAR] <- MBR
MBR <- X
AC <- 1
AC <- AC + MBR
PC <- AC
Clear: AC <- 0
AddI X:
MAR <- X
MBR <- M[MAR]
MAR <- MBR
MBR <- M[MAR]
AC <- AC + MBR
JumpI X:
MAR <- X
MBR <- MAR[X]
PC <- MBR

END - директива - повідомляє Асемблеру, де закінчилась програма.